#+STARTUP: INDENT OVERVIEW
#+TAGS: { Tools : git(g) svn(s) }
#+TAGS: { Concept : uml(u) design(d) }

* 工具相关                                                            :Tools:
** 更好看的git log                                                    :git:
在终端输入:
   #+BEGIN_SRC bash
     git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"
   #+END_SRC
** windows10 svn不显示状态图标                                        :svn:
1. 打开注册表regedit
2. 找到注册表HKEY_LOCAL_MACHINE->SOFTWARE->Microsoft->Windows->CurrentVersion->Explorer->ShellIconOverlayIdentifiers
3. 在所有Tortoisesvn系列的项上重命名, 在其名字前添加若干空格(空格越多优先级越高)直至将相关项移动到此表的前段
4. 重启explorer进程
注意: 如果你的Tortoisesvn系列项已经在前段了, 重启explorer进程依旧不显示图标, 那么打开Tortoisesvn的设置->图标覆盖->状态缓存, 将选项改成Windows外壳

* 概念相关                                                          :Concept:
** UML图                                                              :uml:
*** 类图
用来描述类和类之间关系的UML图
- 类的属性 :: +|-|# name: type [= default_value]
- 类的方法 :: +|-|# name(args list) [: return_type]
- 类的关系(由强到弱)
  - 泛化(Generalization) :: 指继承关系, 实线空心三角箭头, 由子类指向父类
  - 实现(Realization) :: 指接口继承, 子类必须实现父类接口, 虚线空心三角箭头, 由子类指向父类
  - 组合(Aggregation) :: 表明部分是整体的一部分, 且部分无法脱离整体单独存在, 实心棱形三角箭头, 棱形指向整体
  - 聚合(Composition) :: 表明部分是整体的一部分, 部分可以脱离整体存在, 空心棱形三角箭头, 棱形指向整体
  - 关联(Association) :: 指两个类之间有了解, 单向实线箭头指向被了解者, 双向实线
  - 依赖(Dependency) :: 使用关系, 虚线三角箭头, 指向被使用者
  效果图:
  [[file:../res/image/uml_class_diagram.png]]
*** 时序图
描述对象之间发送消息的时间顺序显示多个对象之间的动态协作的UML图
- 角色(Actor) :: 系统角色, 可以是人或者其他系统和子系统, 以一个小人图标表示
- 对象(Object) :: 对象位于时序图的顶部, 以一个矩形表示
- 生命线(LifeLine) :: 时序图中每个对象和底部中心都有一条垂直的虚线, 以一条垂直的
  虚线表
- 控制焦点(Activation) :: 控制焦点代表时序图中在对象时间线上某段时期执行的操作,
  以一个很窄的矩形表示
- 消息(Message) :: 表示对象之间发送的信息, 消息分为三种类型:
  * 同步消息(Synchronous Message)消息的发送者把控制传递给消息的接收者, 然后停止
    活动, 等待消息的接收者放弃或者返回控制. 用来表示同步的意义. 以一条实线和实心
    箭头表示
  * 异步消息(Asynchronous Message)消息发送者通过消息把信号传递给消息的接收者, 然
    后继续自己的活动, 不等待接受者返回消息或者控制. 异步消息的接收者和发送者是并
    发工作的. 以一条实线和大于号表示
  * 返回消息(Return Message)返回消息表示从过程调用返回. 以小于号和虚线表示
- 自关联消息 :: 表示方法的自身调用或者一个对象内的一个方法调用另外一个方法. 以一
  个半闭合的长方形+下方实心箭头表示
效果图:
[[file:../res/image/uml_sequence_diagram.png]]
    
** PlantUML语法                                                       :uml:
*** 类图
:PROPERTIES:
:LINK: [[https://plantuml.com/zh/class-diagram][类图]]
:END:
#+BEGIN_SRC plantuml
@startuml
/' ========== 定义 ========== '/
/'这种格式是注释'/
skinparam packageStyle rectangle /'全局包样式, 可以为rectangle, database, folder'/
                                 /'cloud, frame, node等样式'/
package Package <<node>> #FF0000{ /'包, 其中Package是名字, <<xxx>> 代表样式
                                  /'#开头的3个8位16进制数代表颜色, 可以用#red这种预定义的颜色'/
class Object <<template>> #red-blue{ /'类图 <<>>之间为模板 #后面代表颜色渐变  '/
-- annotation -- /'注解'/
- type private_data /'-代表private'/
.. annotation .. /'注解'/
+ int public_method(int, int) /'+代表public, 参数用逗号隔开 '/
__ /'单分割线'/
# void protect_method() /'#代表protected'/
== /'双分隔线'/
~ package_private_method() /'~代表package_private'/
.. /'省略号'/
}
note left: This is class Object /'类图的左边会出现笔记, 同理right, bottom, top'/

class ChildObject <? extends int> {} /'定义泛型'/

abstract class ABC { /'这是抽象类'/
- int private_data
+ {static} int static_member /'静态成员'/
+ {static} static_method() /'静态方法'/
+ {abstract} abstract_method() /'抽象方法'/
}

note "This is interface" as inf_note /'定义note为inf_note'/
interface Interface { /'这是接口, 不能有非静态成员, 所有方法必须为公开抽象方法'/
+ {static} static_member /'静态成员'/
+ {abstract} abstract_method() /'抽象方法'/
}
Interface .. inf_note /'关联note到Interface上'/

enum Enum { /'这是枚举'/
ENUM_1
ENUM_2
}

set namespaceSeparator :: /'定义命名空间分隔符, 默认为.'/
namespace namespace_1 <<cloud>> #blue { /'这是命名空间, 不同包之间不允许同名类出现, 而这个可以'/
class Nm1Object {}
}
class namespace_2::Nm2Object {} /'隐式定义命名空间'/
/' ========== 关系 ========== '/
Animal <|-- Bird /'泛化关系'/
Fly <|.. Bird /'实现关系'/
Bird "1"*--"2" Wings /'组合关系'/
Nest "1"o--"n" Bird  /'聚合关系'/
Bird "1"-->"1" Climate : 鸟类活动和气候有关 /'关联关系'/
Animal ..> Water : 鸟类需要水 > /'依赖关系'/
Bold -[bold]- Bold /'任意关系的--和..之间可以加上[config]来设置线的样式'/
                   /'如bold, dotted, dashed, hidden, plain, #red等'/
}
@enduml
#+END_SRC
*** 时序图
:PROPERTIES:
:LINK: [[https://plantuml.com/zh/sequence-diagram][时序图]] 
:End:
#+begin_SRC plantuml
@startuml
/'这是注释'/
participant as Foo #red   /'指定参与者, 重命名为Foo, 颜色为红色'/
actor "a 1" as Foo1       /'指定角色, 名称加引号可以包含非字母符号'/
boundary Foo2 #blue       /'指定边界, 一般指交互部分, 颜色为蓝色/
control     as Foo3       /'指定控制'/
entity      as Foo4       /'指定实体, 一般指内部对象'/
database    as Foo5       /'指定数据库'/
collections as Foo6       /'指定集合'/
queue       as Foo7       /'指定队列'/
/'以上命令影响对象的图案'/
autonumber 10 5 /'消息自动编号, 从10开始, 间隔5'/
Foo --> Foo1 ++ : To actor   /'虚线 激活生命线'/
Foo1 --> Foo2 -- : To Foo2  /' 销毁生命线'/
Foo -> New ** : Create /'创建目标实例'/
Foo -> New !! : Destroy /'销毁目标实例'/
Foo2 --> Foo1 --++ #gold : Oops /'同时创建销毁, 生命线颜色为金色'/
note left: this is a not /'单行note, 参数可以为right'/
Foo -> Foo2 : To boundary /'实线'/
return : 返回数据 /' 相当于Foo2 --> Foo --'/
...延迟...  /'延迟图案'/
Foo -[#red]> Foo3 : To control\n  /'红色箭头, 消息换行'/
newpage /'分页'/
Foo ->x Foo4 : To entity  /'丢失消息'/
||| /'额外垂直空间'/
alt condition1  /'条件分组'/
    Foo ->> Foo5 : To database /'细箭头'/
else condition2  /'否则分组'/
    Foo <-> Foo6 : To collections /'双向箭头'/
    loop 1000 /'循环'/
        Foo -/ Foo7 : To queue /'半边箭头'/
    end /'loop 结束'/
    group my-group /'自定义分组'/
    Foo -> Foo /'自循环'/
    end
end /'alt 结束'/
[->Foo : 单向消息 /'不关心来源'/
Foo->] : 单向消息 /'不关心接受方'/
@enduml
#+END_SRC
** MVC模式
MVC 模式(Model–view–controller)是软件工程中的一种软件架构模式, 它把软件系统分为
三个基本部分:模型(Model),视图(View)和控制器(Controller).
MVC模式中三个组件的详细介绍如下:
- 模型(<<<Model>>>) :: 用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法
  "Model"有对数据直接访问的权力, 例如对数据库的访问."Model"不依赖"View"和
  "Controller", 也就是说, Model不关心它会被如何显示或是如何被操作.但是
  Model中数据的变化一般会通过一种刷新机制被公布.为了实现这种机制, 那些用于监视此
  Model的View 必须事先在此Model上注册, 由此, View可以了解在数据Model上发生的
  改变.(比如:观察者模式(软件设计模式)).
- 视图(<<<View>>>) :: 能够实现数据有目的的显示(理论上, 这不是必需的).在 View 中一
  般没有程序上的逻辑.为了实现View上的刷新功能, View需要访问它监视的数据模型(Model)
  , 因此应该事先在被它监视的数据那里注册.
- 控制器(<<<Controller>>>) :: 起到不同层面间的组织作用, 用于控制应用程序的流程.它
  处理事件并作出响应."事件"包括用户的行为和数据Model上的改变.
  
效果图:
[[file:../res/image/mvc_diagram.png]]
  
