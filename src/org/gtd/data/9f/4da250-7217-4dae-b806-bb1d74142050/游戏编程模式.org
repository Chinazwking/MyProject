#+STARTUP: INDENT NUM

* 架构, 游戏和性能
  1. 游戏编程流程图:
     #+BEGIN_VERSE
     遇到问题 \rarr 学习代码 \rarr 解决方案 \rarr 解决问题
     所以尽可能解耦, 使得可以学习较少代码便能得到解决方案
     #+END_VERSE
  2. 在游戏开发期, 游戏的灵活性要大于游戏的效能
     #+BEGIN_VERSE
     游戏的灵活性越大, 开发迭代速度越快, 游戏便越有趣. 将一个好玩的游戏做的高效总
     是比将一款高效的游戏做的有趣要简单
     所以使用抽象使游戏变得灵活, 当其稳定后去除部分抽象提高性能
     #+END_VERSE
  3. 原型开发是完全正确的开发实践
     #+BEGIN_VERSE
     快速的开发一个原型来验证想法, 无需考虑原型的代码设计和维护, 只需要能运行即可
     用完一定要将其丢掉, 如果确认使用则仔细设计并重新实现
     一个比较良好的习惯是使用另一种语言来开发原型, 这样即便你想使用, 也必须用游戏
     语言来重新开发
     #+END_VERSE
  4. 保持游戏的简单性
     #+BEGIN_VERSE
     使用一段代码来处理一系列逻辑, 事物背后是普遍联系的, 找出共性来解决相似的问题
     而不是使用累加的if else
     #+END_VERSE
  5. 经典名言: 提前优化是万恶之源
  6. 如果要做一些有趣的游戏, 请乐在其中

* 命令模式
1. 什么是命令
   #+BEGIN_VERSE
   命令就是面向对象化的回调
   通过命令将输入和操作解耦
   #+END_VERSE
2. 经典场景, 撤销和重做
   #+BEGIN_SRC c++
     class Command {
      public:
       virtual ~Command() {}
       virtual void Execute() = 0;
       virtual void Undo() = 0
     };

     class EditCommand: public Command {
      public:
       EditCommand() {}
       void Execute() {
         // do something
       }
       void Undo() {
         // undo it
       }
     };
   #+END_SRC
   存储一个命令栈:
   older.. | cmd | cmd | cmd | cmd | cmd | newer..
                    \uparrow     \uparrow     \uparrow
                  undo   cur   redo
   每当undo则将三个指针向前移动, redo则向后移动, 如果有新的命令则将cur后面的命令
   全部丢弃
3. 如果存在很多命令, 可以使用[[*子类沙盒][子类沙盒模式]]来在高层提供很多通用函数, 子类命令组合这些函数
4. 如果对象模型存在分层情况, 可以使用[[*责任链][责任链模式]]来将命令转发给附属对象
5. 如果命令是无状态的代码块, 可以使用[[*享元模式][享元模式]]来降低内存使用
   
* 享元模式
1. 什么是享元
   #+BEGIN_VERSE
   当大量对象内部数据分为两种类型:
   - 内部数据(上下文无关): 这部分数据在所有的对象中都是一致的, 和所处的对象没有关系
   - 外部数据(上下文相关): 这部分数据代表每个对象自己的特征
   通过将内部数据存储到一个对象中, 大量对象持有内部数据的引用即可有效的减少内存的使用
   我们把这些内部对象称为享元(共享的单元)
   #+END_VERSE
2. 经典场景, 瓦片世界
   #+DESCRIPTION: 实现一个拥有不同地形的世界
   #+BEGIN_SRC c++
     class Terrain {  // 地形类, 拥有自己的移动开销和纹理
      public:
       Terrain(int movecost, Texture texture);
       int getMoveCost() const;
       const Texture& getTexture() const;

      private:
       int _movecost;
       Texture _texture;
     };

     class World {
      public:
       World() {
         _landtile = Terrain(10, landTexture);
         // ...其他地形初始化
         for (int i = 0; i < 1000; ++i) {
           for (int j = 0; j < 1000; ++j) {
             _world[i][j] = choice(); // 在4中地形中随机选择一个
           }
         }
       }

      private:
       // 4种独特地形的引用
       Terrain* _landtile;
       Terrain* _watertile;
       Terrain* _foresttile;
       Terrain* _sandtile;

       // 世界所有地块
       Terrain* _world[1000][1000];
     }
   #+END_SRC
   假设一个游戏的世界由若干不同地形构成, 每种地形都有自己的移动开销和纹理, 因为地形的
   种类是有限的, 但是整个世界的地块确可能存在千千万万, 这里便可以应用享元模式.
   不必未每个地块单独生成自己的地形, 而是让若干地块共享一个地形实例
3. 如果不能预测共有多少享元, 那么最好按需创建, 可以使用[[*][工厂模式]]管理创建操作
4. 为了更方便的管理享元, 可以使用[[*对象池][对象池模式]]来管理
5. [[*状态模式][状态模式]]的状态也可以使用享元来表现

* 观察者模式
1. 什么是观察者
   #+BEGIN_VERSE
   在对象之间定义一种一对多的关系, 以便当某个对象改变时, 与他存在依赖关系的所有对象
   都能收到通知并自动更新
   #+END_VERSE
2. 经典场景, 成就系统
   #+DESCRIPTION: 实现一个物理和成就系统解耦的系统
   #+BEGIN_SRC c++
     class Observer {
      public:
       virtual ~Observer() {}
       virtual void onNotify(const Entity& entity, Event event) = 0;
     };

     class Achievements: public Observer {
      public:
       virtual void onNotify(const Entity& entity, Event event) {
         switch (event) {
           case EVENT_FELL:
             if (entity.isHero()) {
               unlock(ACHIEVEMENT_FELL);  // 解锁跌落成就
             }
             break;
         }
       }

      private:
       void unlock(Achievement achievement) {
         // 解锁成就
       }
     };

     class Subject {
      public:
       void addObserver(Observer* observer) {
         // 加到观察者列表中
       }

       // 移除观察者等其他操作

      protected:
       void notify(const Entity& entity, Event event) {  // 通知所有观察者
         for(auto& observer : _observers) {
           observer->onNotify(entity, event)
         }
       }

      private:
       Observer* _observers[MAX_OBSERVERS];
     };

     class Physics: public Subject {  // 物理系统
      public:
       void updateEntity(Entity& entity) {
         notify(entity, EVENT_FELL);  // 发出掉落信号
       }
       // 其他接口
     };
   #+End_src
   当玩家坠地时解锁成就玩家坠落, 但是很明显玩家坠地属于物理系统, 而在物理系统处理成就
   会非常奇怪, 而且玩家坠地也有可能有声音, 动画等等特效, 很明显不能将这些效果和物理系统
   耦合到一起, 物理系统只应该处理物理相关的事.
   通过将成就系统注册为物理系统的观察者, 使得物理无需和成就系统耦合. 物理系统只需要
   处理物理相关的事件并广播出去, 并不关心其他系统如何处理, 最终实现了成就系统和物理
   系统同步且两者可以独立变化
3. 当一个观察者或被观察者过期时, 注意两者的销毁
4. 观察者适用于处理不相关模块的通信问题, 不适用于在单个紧凑的内部模块内通信使用
5. 目前更流行使用更灵活的观察者方法, 比如注册一个观察函数, 而不是继承一个类

* 原型模式
1. 什么是原型
   #+BEGIN_VERSE
   使用特定原型实例来创建特定种类的对象, 并且通过拷贝原型来创建新的对象
   #+END_VERSE
2. 经典场景, 怪物系统
   #+CAPTION: 怪物实现
   #+BEGIN_SRC c++
     class Monster {
      public:
       virtual ~Monster() {}
       virtual Monster* clone() = 0;
     };

     class Slime : public Monster {
      public:
       Slime(int health, int speed)
           :_health(health) {}

       virtual Monster* clone() {
         return new Slime(_health)
       }

      private:
       int _health;
     };
   #+End_src
   无需定义工厂函数, 通过clone方法, 每个实例可以复制自身, 并且同时复制自身的状态
   来创建若干个怪物对象
   #+CAPTION: 怪物数据建模
   #+BEGIN_SRC json
     [
         {
             "name": "slime",
             "maxHealth": 100,
             "resists": ["cold", "posion"],
             "weakness": ["fire", "light"]
         },
         {
             "name": "slime queen",
             "prototype": "slime",
             "spells": ["fire ball", "ice nova"]
         },
         {
             "name": "slime king",
             "prototype": "slime",
             "attacks": ["cyclone", "charge"]
         }
     ]
   #+END_SRC
   通过为每个怪物json设置原型字段, 可以有效实现相似怪物的属性共享, 新建怪物类型也
   非常简单, 使用prototype字段设置一个原型
3. 实现原型的clone时, 一定要注意对象的拷贝问题(深拷贝, 浅拷贝)
4. [[*类型对象][类型对象模式]]和和原型模式有一定的共同点

* 单例模式
1. 什么是单例
   #+BEGIN_VERSE
   确保一个类只有一个实例, 并为其提供一个全局访问入口
   #+END_VERSE
2. 经典场景, 文件系统
   #+DESCRIPTION: 实现一个跨平台的公共文件系统接口
   #+BEGIN_SRC c++
     class FileSystem {
      public:
       static FileSystem& instance() {
         #if PLATFORM = PLAYSTATION4
           static FileSystem* instance = new PS4FileSystem();
         #elif PLATFORM = SWITCH
           static FileSystem* instance = new SwitchFileSystem();
         #endif
         return *instance
       }
       virtual ~FileSystem() {}
       virtual char* read(char* path) = 0;
       virtual void write(char* path, char* text) = 0;

      private:
       FileSystem() {}
     };

     class PS4FileSystem: public FileSystem {
      public:
       virtual char* read(char* path) {}
       virtual void write(char* path, char* text) {}
     };

     class SwitchFileSystem: public FileSystem {
      public:
       virtual char* read(char* path) {}
       virtual void write(char* path, char* text) {}
     };
   #+End_src
   C++11保证局部静态变量只会初始化一次且线程安全, 通过instace接口, 全局
   都访问同一个FileSystem实例, 通过继承和简单的编译跳转实现了跨平台的文件
   系统功能封装
3. 不要滥用单例模式
   1. 他是一个全局变量
      1. 由于任何位置都能修改单例, 导致追踪问题时需要额外考虑全局单例状态, 导致
         代码晦涩难懂
      2. 全局变量促进了耦合, 由于单例的易访问性, 使用者很可能在任何位置都不自主的
         使用单例, 导致不相干的模块耦合到一起
      3. 对并发不友好
   2. 延迟初始化不一定是件好事, 在错误的时间初始化可能导致游戏明显卡顿, 所以
      很多时候会选择静态类初始化, 此时单例没有意义
4. 单例的替代品
   1. 首先考虑你是否真的需要单例
   2. 是否可以通过传参的方式替代单例
   3. 是否可以在基类中获取
   4. 将分散的单例作为成员变量封装到一个全局对象中
   5. 使用[[*服务定位器][服务定位器]]来访问
   6. [[*子类沙盒][子类沙盒]]可以为子类提供一些共享的状态访问, 而不必全局可见
* 状态模式
1. 什么是状态模式
   #+BEGIN_VERSE
   允许一个对象在其内部状态改变时改变自身的行为, 对象看起来好像在修改自身类
   #+END_VERSE
2. 经典场景, 动作系统
   #+CAPTION: 有限状态机
   #+DESCRIPTION: 为人物主角的每个动作关联图像, 并在各种动作(跳跃, 闪避, 下蹲, 攻击)中切换
   #+BEGIN_SRC c++
     class HeroState {
      public:
       virtual ~HeroState() {}
       virtual HeroState* handleInput(Hero& hero, Input input) = 0;  // 处理输入
       virtual void update(float time) = 0;  // 每帧的动作
       virtual void enter(Hero& hero) = 0;  // 进入此状态执行的操作
     };

     class Hero {
      public:
       void handleInput(Input input) {
         HeroState* new_state = _state->handleInput(*this, input);
         if (new_state != nullptr) {
           delete _state;
           _state = new_state;
           _state->enter(*this);
         }
       }
       void update(float time) {
         _state->update(time);
       }
      private:
       HeroState* _state;
     };

     class DuckState: public HeroState {
      public:
       DuckState() {}
       HeroState* handleInput(Hero& hero, Input input) override {
         if (input == RELEASE_DOWN) {
           return new StandState();
         } else {
           return nullptr;
         }
       }
       void update(float time) override {}
       void enter(Hero& hero) override {
         hero.SetGraphics(IMAGE_DUCK);
       }
     };

     class StandState: public HeroState {
      public:
       StandState() {}
       HeroState* handleInput(Hero& hero, Input input) override {
         if (input == PRESS_DOWN) {
           return new DuckState();
         } else if (input == PRESS_UP) {
           return new JumpState();
         } else if (input == PRESS_B) {
           return new DodgeState();
         } else {
           return nullptr;
         }
       }
       void update(float time) override {}
       void enter(Hero& hero) override {
         hero.SetGraphics(IMAGE_STAND);
       }
     };

     class JumpState: public HeroState {
      public:
       JumpState() {}
       HeroState* handleInput(Hero& hero, Input input) override {
         if (_play_time > 1) {
           return new StandState();
         } else {
           return nullptr;
         }
       }
       void update(float time) override {
         if (_play_time == 0) {
           _play_time = time;
         } else {
           _play_time = time - _play_time;
         }
       }
       void enter(Hero& hero) override {
         hero.SetGraphics(IMAGE_JUMP);
       }
      private:
       float _play_time = 0;
     };

     class DodgeState: public HeroState {
      public:
       DodgeState() {}
       HeroState* handleInput(Hero& hero, Input input) override {
         if (_play_time > 1) {
           return new StandState();
         } else {
           return nullptr;
         }
       }
       void update(float time) override {
         if (_play_time == 0) {
           _play_time = time;
         } else {
           _play_time = time - _play_time;
         }
       }
       void enter(Hero& hero) override {
         hero.SetGraphics(IMAGE_DODGE);
       }
      private:
       float _play_time = 0;
     };
   #+END_SRC
   使用状态机有效避免了同时维护多种状态和使用多个ifelse语句, 每个状态只需要处理自
   己接受的输入并转换为对应的状态. 如果不使用状态机而只是单纯的使用ifelse语句, 随
   着状态的增加会越来越难以维护(比如跳跃时是否可以下蹲?, 是否可以攻击?)
3. 状态的两种形式
   - 如果状态本身是无状态的, 那么所有相同状态之间可以共享一个相同实例
   - 如果状态本身是有状态的, 那么需要为每个状态创建实例
4. 有限状态机
   - *你拥有一组状态, 并且可以再这组状态之间切换*
   - *状态机同一时刻只能处于一种状态*
   - *状态机会接收一组输入或者事件*
   - *每个状态都有一组转换, 每一个转换都关联着一个输入并指向另一个状态*
5. 并发状态机
   如果存在另一种类型的状态, 和当前的状态无关, 那么可以额外维护一个新的状态, 用两
   个状态机而不是一个状态机来表示. 假设之前有n个状态, 新增的有m个状态, 那么使用
   一个状态机共有 /mxn/ 种状态要处理, 而使用两个状态机只需要 /m+n/ 种状态
6. 层次状态机
   如果很多状态有大量相似的状态, 那么可以为这些状态设置父状态, 当子状态无法处理输
   入时, 交给父状态来处理, 如果所有父状态都无法处理则忽略此输入
   1. 使用继承来实现, 父类实现共性状态
   2. 不再使用一个状态变量, 而是维护一个状态栈来实现, 子状态在栈顶, 下面依次是他
      的父状态, 父状态的父状态, 以此类推, 栈底是祖先
7. 下推状态机
   如果你的状态需要历史记录(当前状态结束想要回到上一个状态), 那么可以维护一个状态
   栈:
   - 当前状态永远在栈顶. 当状态切换的时候, 将当前状态压栈, 然后将新状态入栈
   - 当想切换到之前的状态时, 将栈顶出栈即可
8. 状态模式的使用场景
   - 你有一个游戏实体, 它的行为基于它的内部状态而改变
   - 这些状态被严格划分为相对数目较少的小集合
   - 游戏实体随着时间变化会相应用户的输入和游戏事件
* 双缓冲
1. 什么是双缓冲
   #+BEGIN_VERSE
   维护两个缓冲区, 当前缓冲区和后台缓冲区. 每当读取数据时, 总是从当前缓冲区读取,
   每当修改数据时, 总是修改后台缓冲区, 当修改完成时, 交换两者. 使得当前缓冲区变
   为后台缓冲区以供复用
   #+END_VERSE
2. 经典场景, 视频渲染
   #+CAPTION: 视频渲染原理
   #+BEGIN_SRC c++
     class FrameBuffer {  // 帧缓冲
      public:
       FrameBuffer() {}
       void clear(); // 清空全部内容
       void draw(int x, int y);  // 修改某个像素的值
       char getPixel(int x, int y); // 获得某个像素的值

       static const int WIDTH = 1920;
       static const int HEIGHT = 1080;

      private:
       char _pixels[WIDTH*HEIGHT];
     };

     class Scene {
      public:
       Scene(): _current(&_buffers[0]), _backstage(&_buffers[1]) {}
       void draw() {  // 绘制新的画面
         _backstage->clear();
         for (int i = 0; i < FrameBuffer::HEIGHT; ++i) {
           _backstage->draw(i, i); // 绘制斜线
         }
         swap();
       }

       Framebuffer& getBuffer() { return *_current; }  // 获得当前的画面

      private:
       void swap() {
         FrameBuffer* tmp = _backstage;
         _backstage = _current;
         _current = tmp;
       }

       FrameBuffer _buffers[2];
       FrameBuffer* _current;  // 当前缓冲, 用于显示
       FrameBuffer* _backstage; // 后台缓冲, 用于写入
     };
   #+END_SRC
   通过维护两个缓冲, 有效的避免了渲染的时候修改正在被渲染的数据导致画面撕裂, 使用
   双缓冲的主要目的正是为了解决这两种情况:
   - 状态直接被中断或者另一个线程的代码所访问
   - 进行状态修改的代码访问到了其正在修改的那个状态
   视频渲染正是第一种情况
3. 使用情景:
   * 我们需要维护一些被逐步改变的状态量
   * 同个状态可能在被修改的时候被访问到
   * 我们希望避免访问状态的代码看到具体的工作过程
   * 我们希望能够读取状态但不希望等待写入操作完成
4. 缓冲区如何被交换
   - 交换指针 :: 简单高效, 但是无法复用当前缓冲的数据
   - 数据拷贝 :: 将后台数据拷贝到当前缓冲, 当前永远落后后台一帧, 可以实现数据复用
     对于小的缓冲区来说是可以接受的, 但当缓冲区很大的时候复制会消耗大量时间
5. 缓冲区的粒度
   - 缓冲区是单个整体 :: 交换一次即可
   - 缓冲区分布在多个对象之中 :: 依次遍历每个对象来完成交换
* 游戏循环
1. 什么是游戏循环
   #+BEGIN_VERSE
   "实现用户输入和处理器速度在游戏进行时间上的解耦"
   通俗来说就是维护一个循环使游戏一直运转, 同时可以不阻塞的响应用户的输入
   #+END_VERSE
2. 经典场景
   #+CAPTION: 基础游戏循环结构, 非同步固定时间步长
   #+BEGIN_SRC c++
     while (true) {
       processInput();  // 处理用户输入
       update();  // 更新游戏内部状态
       render();  // 渲染游戏内容
     }
   #+END_SRC
   这是游戏循环的核心逻辑, 但是机能和一帧内处理的信息会影响游戏的速度, 你无法
   控制游戏速度的快慢, 在性能强劲的机器上和垃圾的机器上运行速度天差地别
   #+CAPTION: 同步固定时间步长
   #+BEGIN_SRC c++
     const double MS_PER_FRAME = 16.6;  // 每一帧的时间设置为16ms, 1000ms/MS_PER_FRAME = 60FPS
     while (true) {
       double start = getCurrentTime();
       processInput();
       update();
       render();

       sleep(start + MS_PER_FRAME- getCurrentTime());  // 当处理速度很快时, 将休眠等待真实时间
     }
   #+END_SRC
   这种方法可以保证如果处理速度很快, 游戏也会按照固定的速度的运行. 但是如果游戏
   运行速度慢这个方法将退化到基础循环的情况
   #+CAPTION: 变时步长
   #+BEGIN_SRC c++
     double lastTime = getCurrentTime();
     while (true) {
       double current = getCurrentTime();
       double elapsed = current - lastTime;
       processInput();
       update(elapsed); // 根据两帧之间的间隔动态计算游戏状态
       render();
       lastTime = current;
     }
   #+END_SRC
   首先这种方法确实可以让不同的硬件以相同的速度运行, 但是有一个非常严重的问题, 它
   会让游戏变得不稳定. 因为不同机器update调用的次数是不一致的, 快的多, 慢的少,
   如果游戏内部有浮点数累加等操作, 调用update会迅速累积大量误差.
   #+CAPTION: 定时更新, 变时渲染
   #+BEGIN_SRC c++
     double previous = getCurrentTime();
     double lag = 0.0;
     while (true) {
       double current = getCurrentTime();
       double elapsed = current - previous;
       previous = current;
       lag += elapsed;  // lag代表游戏状态时间落后于真实时间的值
       processInput();

       while (lag >= MS_PER_UPDATE) { // 每当落后一个MS_PER_UPDATE, 更新游戏状态, 追回时间
         update();
         // 这里要注意MS_PER_UPDATE必须要大于update消耗的时间, 如果小于则永远无法追上真实时间
         lag -= MS_PER_UPDATE;
       }
       render(lag/MS_PER_UPDATE); // 为了避免两帧渲染相同画面, render需要根据落后时间计算画面
     }
   #+END_SRC
   这个是最具有普适性的游戏循环方法, 通过将渲染和更新分离, 可以适应过快或者过慢的
   平台, 不同机器update速度是一致的, 但是性能好的机器可以 享受到更好的游戏体验
   (render次数更多)
3. 使用场景:
   只要是游戏一定会用到, 这就是91定律里面的10%部分的代码, 这里的一点点错误会影响
   到整个游戏
4. 谁来控制游戏循环
   * 平台事件循环
     - 相对简单
     - 与平台完美兼容
     - 失去了对游戏时间的控制, 而且实现理念很可能不适合于游戏
   * 游戏引擎游戏循环
     - 当出现一些和游戏引擎循环不合拍的需求时, 你无法获得控制权
   * 自己编写游戏循环
     - 掌控一切, 可以随心所欲
     - 需要实现各个平台接口, 并且要定期将操作权交给系统来保证框架的稳定
5. 能量损耗
   在pc上可以不限制帧率, 能跑多快就跑多快, 但是在移动设备上最好限制帧率, 让多余的
   时间用来休眠, 有效降低电量损耗
   
* 更新方法
1. 什么是更新方法
  #+BEGIN_VERSE
  "通过对所有对象实例同时进行帧更新来模拟一系列互相独立的游戏对象"
  通过为每个对象实现一个更新方法, 游戏循环在每一帧对所有的对象调用其更新方法
  #+END_VERSE
2. 经典场景, 怪物守卫
   #+BEGIN_SRC c++
     class Entity { // 游戏内的实体基类
      public:
       virtual ~Entity() {}
       virtual void update() = 0;

       void move(double x, double y) {
         _x += x;
         _y += y;
       }

      private:
       double _x; // 位置
       double _y;
     };

     class Zombie: public Entity {
      public:
       Zombie() {}
       void update() override {
         move(5, 0); // 只会横着走
       }
     };

     class Statue: public Entity {
      public:
       Statue() {}
       void update() override {
         move(0, 0); // 雕像不会移动
       }
     };

     class World {
      public:
       World() {}
       void gameLoop() {
         for (auto& entity : _entities) {
           entity->update();
         }
       }

      private:
       Entity* _entities[MAX_ENTITIES];
     };
   #+END_SRC
   通过为每个实体实现各自的update函数, 每个实体可以只关注自身的行为, 游戏循环
   也不需要关心每个实体具体的更新方式, 非常易于维护和增加新的实体行为
3. 使用场景:
   * 你游戏里有一系列对象需要同步的运转
   * 各个对象之间的行为几乎是独立的
   * 对象的行为与时间有关
4. 未激活对象的处理方式
   * 如果使用单个集合来存储所有对象
     - 需要用标识位来指明对象的有效性, 如果无效对象较多可能会大量的时间, 而且也会
       破坏数据的局部性([[*数据局部性][数据局部性模式]])
   * 如果维护一个集合专门存储活跃对象
     - 你需要用两份内存来维护对象, 但是速度上会有很大的提升
     - 必须要保持两个集合同步
5. 这一部分与[[*游戏循环][游戏循环]]和[[*组件模式][组件模式]]共同构成了游戏引擎的核心部分
* 字节码
* 子类沙盒
* 类型对象
* 组件模式
* 事件队列
* 服务定位器
* 数据局部性
* 脏标记模式
* 对象池
* 空间分区
