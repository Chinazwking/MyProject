#+STARTUP: INDENT NUM

* 架构, 游戏和性能
  1. 游戏编程流程图:
     #+BEGIN_VERSE
     遇到问题 \rarr 学习代码 \rarr 解决方案 \rarr 解决问题
     所以尽可能解耦, 使得可以学习较少代码便能得到解决方案
     #+END_VERSE
  2. 在游戏开发期, 游戏的灵活性要大于游戏的效能
     #+BEGIN_VERSE
     游戏的灵活性越大, 开发迭代速度越快, 游戏便越有趣. 将一个好玩的游戏做的高效总
     是比将一款高效的游戏做的有趣要简单
     所以使用抽象使游戏变得灵活, 当其稳定后去除部分抽象提高性能
     #+END_VERSE
  3. 原型开发是完全正确的开发实践
     #+BEGIN_VERSE
     快速的开发一个原型来验证想法, 无需考虑原型的代码设计和维护, 只需要能运行即可
     用完一定要将其丢掉, 如果确认使用则仔细设计并重新实现
     一个比较良好的习惯是使用另一种语言来开发原型, 这样即便你想使用, 也必须用游戏
     语言来重新开发
     #+END_VERSE
  4. 保持游戏的简单性
     #+BEGIN_VERSE
     使用一段代码来处理一系列逻辑, 事物背后是普遍联系的, 找出共性来解决相似的问题
     而不是使用累加的if else
     #+END_VERSE
  5. 经典名言: 提前优化是万恶之源
  6. 如果要做一些有趣的游戏, 请乐在其中

* 命令模式
1. 什么是命令
   #+BEGIN_VERSE
   命令就是面向对象化的回调
   通过命令将输入和操作解耦
   #+END_VERSE
2. 经典场景, 撤销和重做
   #+BEGIN_SRC c++
     class Command {
      public:
       virtual ~Command() {}
       virtual void Execute() = 0;
       virtual void Undo() = 0
     };
   #+END_SRC
   存储一个命令栈:
   older.. | cmd | cmd | cmd | cmd | cmd | newer..
                    \uparrow     \uparrow     \uparrow
                  undo   cur   redo
   每当undo则将三个指针向前移动, redo则向后移动, 如果有新的命令则将cur后面的命令
   全部丢弃
3. 如果存在很多命令, 可以使用[[*][子类沙盒模式]]来在高层提供很多通用函数, 子类命令组合这些函数
4. 如果对象模型存在分层情况, 可以使用[[*责任链][责任链模式]]来将命令转发给附属对象
5. 如果命令是无状态的代码块, 可以使用[[*享元模式][享元模式]]来降低内存使用
   
* 享元模式
1. 什么是享元
   #+BEGIN_VERSE
   当大量对象内部数据分为两种类型:
   - 内部数据(上下文无关): 这部分数据在所有的对象中都是一致的, 和所处的对象没有关系
   - 外部数据(上下文相关): 这部分数据代表每个对象自己的特征
   通过将内部数据存储到一个对象中, 大量对象持有内部数据的引用即可有效的减少内存的使用
   我们把这些内部对象称为享元(共享的单元)
   #+END_VERSE
2. 经典场景, 瓦片世界
   #+BEGIN_SRC c++
     class Terrain {  // 地形类, 拥有自己的移动开销和纹理
      public:
       Terrain(int movecost, Texture texture);
       int getMoveCost() const;
       const Texture& getTexture() const;

      private:
       int _movecost;
       Texture _texture;
     };

     class World {
      public:
       World() {
         _landtile = Terrain(10, landTexture);
         // ...其他地形初始化
         for (int i = 0; i < 1000; ++i) {
           for (int j = 0; j < 1000; ++j) {
             _world[i][j] = choice(); // 在4中地形中随机选择一个
           }
         }
       }

      private:
       // 4种独特地形的引用
       Terrain* _landtile;
       Terrain* _watertile;
       Terrain* _foresttile;
       Terrain* _sandtile;

       // 世界所有地块
       Terrain* _world[1000][1000];
     }
   #+END_SRC
   假设一个游戏的世界由若干不同地形构成, 每种地形都有自己的移动开销和纹理, 因为地形的
   种类是有限的, 但是整个世界的地块确可能存在千千万万, 这里便可以应用享元模式.
   不必未每个地块单独生成自己的地形, 而是让若干地块共享一个地形实例
3. 如果不能预测共有多少享元, 那么最好按需创建, 可以使用[[*][工厂模式]]管理创建操作
4. 为了更方便的管理享元, 可以使用[[*对象池模式][对象池模式]]来管理
5. [[*状态机模式][状态机模式]]的状态也可以使用享元来表现
