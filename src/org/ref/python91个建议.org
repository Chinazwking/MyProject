#+STARTUP: INDENT NUM

* 理解pythonic概念
#+BEGIN_VERSE
所谓的pythonic, 即是看起来充分利用python本身的特性而编写的代码.
比如交换使用a, b = b, a, 遍历使用for i in arr, 打开文件使用with, 这些语法都是别的
语言所不具有的, 编程时要积极使用这些语法.
#+END_VERSE
1. 字符串格式化使用format
2. 包, 模块使用小字母命名且最好短小精悍, 包仅作为命名空间, __init__.py为空

* 编写pythonic代码
#+BEGIN_VERSE
想要编写pythonic的代码, 归根结底还是要全面掌握python特性, 不断学习官方推荐的新的
语法, 阅读设计良好的代码库来加深对python特性的掌握, 才能写出pythonic的代码.
#+END_VERSE
1. 变量命名
   * 避免无意义的单字母
   * 命名最好有意义, 不要产生混淆
   * 不要惧怕长命名
2. 熟练使用工具来检查代码, 比如pylint, pep8等等

* 理解python和c语言的不同之处
#+BEGIN_VERSE
虽然python是用c编写的, 但是很多语法规则上完全不同, 不要用c的思维套用到python上
#+END_VERSE
1. python使用空白缩进
2. python单引号和双引号语义上基本一致
3. python的三元操作符为xx if xx else xx
4. python没有switch, 可以用if else或者字典分发代替

* 在代码中适当添加注释
#+BEGIN_VERSE
合适的代码注释是非常有必要的, 无论是个人回顾还是提供给别人调用, 有效的注释能够节
省大量时间.
#+END_VERSE
1. 注释和代码保持一定距离更加清晰
2. 接口提供详细注释
3. 对复杂代码的思路注释而不是对实现注释
4. 错误的注释还不如没有注释, 所以更新代码时即时更新注释

* 通过适当添加空行使得代码更加优雅
#+BEGIN_VERSE
使用适当的空行分隔不同逻辑可以让代码更加有条理, 更加容易阅读
#+END_VERSE
1. 全局定义之间空两行, 类内方法空一行, 一块代码内的不同逻辑空一行
2. 一行不要超过80(这个应该是针对老式电脑编辑器的约定, 目前现代ide是否要保留感觉有
   待商榷)
3. 不要为了保持对齐而强行加入大量空白
4. 具有紧密关系的代码间不要加空格, 比如a[3], 稀疏关系的加上空格, 比如a == b
5. 空格可以用来强调关系, 比如-5 - 2, 强调是减法而不是负号

* 编写函数的四个原则
#+BEGIN_VERSE
短小精悍, 设计合理, 向下兼容, 职责明确
#+END_VERSE
1. 函数尽量短小, 循环嵌套不超过3层
2. 函数接口合理易用, 参数不宜过多
3. 设计时考虑向下兼容
4. 一个函数只做一件事, 保持同一级函数的抽象层次一致性

* 将常量集中到一个文件
#+BEGIN_VERSE
将常量定义到一个文件之中, 便于查看和维护
#+END_VERSE
两种实现方式:
   * 直接大写MAX_VALUE, 约定用法
   * 定义一个模块:
     #+BEGIN_SRC python
       class _Const:
           class ConstError(TypeError): pass
           class ConstCaseError(ConstError): pass
           def __setattr__(self, name, value):
               if self.__dict__.has_key(name):
                   raise self.ConstError, "Can't change const.%s".format(name)
               if not name.isupper():
                   raise self.ConstCaseError, "%s is not uppercase".format(name)
               self.__dict__[name] = value

       import sys
       sys.modules[__name__] = _Const()

       import const
       const.MY_CONSTANT = 1
     #+END_SRC
     使用这种方式定义可以确保变量值不变并且一定是大写

* 利用assert语句发现问题
#+BEGIN_VERSE
断言是用来捕获约束而不是捕获错误的
具体来说, 断言是用来处理程序继续执行逻辑上前提条件, 而不是具体捕获异常
#+END_VERSE
1. 不要滥用, 影响性能
2. python自身能处理就不要用断言
3. 不要用来检查用户输入
4. 可以用来检测函数返回值是否合理

* 数据交换值不推荐使用中间变量
#+BEGIN_VERSE
pythonic的交换方式是a, b = b, a
比传统的中间变量交换法更优雅且更高效
#+END_VERSE

* 充分利用lazy evaluation的特性
#+BEGIN_VERSE
利用延时计算可以节省空间, 提升性能
#+END_VERSE
1. 利用and, or的求值短路特性节省时间
2. 利用生成器节省空间

* 理解枚举替代实现的缺陷
#+BEGIN_VERSE
python3.4之前模拟的枚举存在很多缺陷, 3.4支持Enum
#+END_VERSE
1. 替代枚举可以重复赋值
2. 可以进行无意义的操作

* 不推荐使用type进行类型检查
#+BEGIN_VERSE
python的理念就是通过自动类型检查并根据需要隐式转换, 如果不行则抛出异常, 所以一般
不会主动进行类型检查
#+END_VERSE
1. type无法识别继承自内建类的类型
2. type无法识别古典类之间的区别
3. 一定要检查使用isinstance

* 尽量转换为浮点型后再做除法
#+BEGIN_VERSE
python2.7 两个整形之间默认的除法是整形除法, 会截断小数, 所以两个整数相除截断这个
效果是你想要的, 否则手动转为浮点型
#+END_VERSE
1. 可以再python2.7中使用from __future__ import division来使得默认使用浮点除法
2. 浮点数不要使用==比较, 使用a-b<=decision来指定精度进行比较

* 警惕eval()的安全漏洞
#+BEGIN_VERSE
"eval is evil"
#+END_VERSE
1. 用户可能通过eval执行破坏性代码, 所以eval不能出现在用户可能会调用的位置上
2. eval导致代码调试困难
3. 一定要暴露给用户可以使用ast.literal_eval

* 使用enumerate()获取序列迭代的索引和值
#+BEGIN_VERSE
enumerate可以优雅的处理同时获取索引和迭代值的问题, 更棒的一点是他是惰性的.
#+END_VERSE
1. 对字典使用获取的是索引和key二元组, 这个要注意

* 分清==和is的使用场景
#+BEGIN_VERSE
is判断是不是一个对象, 而==判断是不是一个值
#+END_VERSE
1. 是否为同一个对象可以理解为是不是在内存中指向同一个区域
2. == 实际上调用的是__eq__魔术方法

* 考虑兼容性, 尽可能使用Unicode
#+BEGIN_VERSE
通过统一使用unicode, 可以解决让人头疼的乱码问题
#+END_VERSE
1. 使用from __future__ import unicode_literals 可以让所有的字面量变为unicode

* 构建合理的包层次来管理module
#+BEGIN_VERSE
python中的包是用来管理组织代码结构的工具, 通过一层层目录结构, 可以使得避免不同路
径下的两个同名模块发生冲突, 并且可以根据模块的功能将其放到不同的包中, 使得代码结
构更加清晰.
#+END_VERSE
1. 通过合理的使用包, 可以让代码:
   * 便于维护和使用
   * 最大程度避免命名冲突

* 有节制的使用from ... import语法
#+BEGIN_VERSE
from import 语法虽然在有些时候减少代码量, 但是很容易导致命名冲突, 循环导入问题,
而且也不方便在运行时打猴子补丁
#+END_VERSE
1. from xx import *, 最好别用
2. from xx import ABC, 导入属性少用, 导入模块可以用
3. import xxx, 除了导致代码变长, 用起来麻烦, 其他都是优点

* 优先使用绝对导入
#+BEGIN_VERSE
绝对不要使用隐式相对导入, 有节制的使用相对导入, 最好使用绝对导入.
#+END_VERSE
1. from __future__ import absolute_import可以禁止隐式相对导入
2. 相对导入在作为顶级模块执行时会丢失自己的层次信息, 导致相对导入失效

* i+=1 不等于 ++i
#+BEGIN_VERSE
python不支持自增, ++i在python等效于+(+i), 所以这句话约等于无事发生
#+END_VERSE

* 使用with自动关闭资源
#+BEGIN_VERSE
with语句是更加优雅简单的资源管理方法, 通过with管理资源可以替代老式的
try/catch/finally式写法
本质上支持with语法的对象实现了__enter__和__exit__两个接口用来控制
资源状态
#+END_VERSE
1. 推荐使用contextlib中的contextmanager装饰器来实现自己的上下文管理器
   形式大概类似于:
   #+BEGIN_SRC python
     @contextmanager
     def mycontext():
         print('__enter__')
         # 为了确保yield的对象抛出异常能够正确__exit__, 最好还是使用try, finally
         try:
             yield 0  # yield之前为__enter__, 之后为__exit__, 返回的值会赋值给as的对象
         finally:
             print('__exit__')
   #+END_SRC
   
* 使用else字句简化循环
#+BEGIN_VERSE
else在循环中, 非break时调用, else在异常中, 没有发生异常时调用. 合理的使用else
可以减少状态变量的使用
#+END_VERSE

* 遵循异常处理的几点基本原则
#+BEGIN_VERSE
精准, 高粒度的使用异常, 注意异常捕获顺序, 正确处理异常重抛出
#+END_VERSE
1. 不要except所有异常
2. try包含的语句越少越好
3. except的异常越具体越好
4. 越在继承链底部的异常, 越应该将他放到多个except语句的前面, 以便精准捕获
5. 异常抛出的信息最好对开发, 用户更加友好

* 避免finally中可能发生的陷阱
#+BEGIN_VERSE
finally不是银弹, 并不能解决一切由异常导致的问题
#+END_VERSE
1. 如果finally里又出现了新的异常或者直接返回, 旧的异常会丢失
2. finally如果存在返回, 会截断正常的返回, 所以一般不在finally返回

* 深入理解None, 正确判断对象是否为空
#+BEGIN_VERSE
None不是空, 当一个值和None比较时, 当且仅当值也为None时他们才相等, 其他情况一律不
等
#+END_VERSE
1. python会根据对象的__nonzero__和__len__判断对象是否为空, 如果没实现这两个接口则
   默认为不空

* 连接字符串优先使用join而不是+
#+BEGIN_VERSE
在处理大规模字符串连接时, join的效率远远高于+, 所以使用join连接字符
#+END_VERSE
1. join一次性计算需要的内存, 然后将内容复制到新的字符串中
2. 每+一次都在内存中复制字符串一遍, 所以大数量时效率低

* 格式化字符串尽量使用format而不是%
#+BEGIN_VERSE
不要使用%格式化, 一律使用format
#+END_VERSE
1. 功能更强大, 更灵活, 更方便
2. %最终会被format替代

* 区别对待可变对象和不可变对象
#+BEGIN_VERSE
不可变对象的值无法改变, 而可变对象的值可以改变. 有些时候你以为不可变对象的值变了,
实际上并不是值变了, 而是给你的标识符分配了新的对象
#+END_VERSE
1. 函数默认参数绝对不要使用可变参数, 所有对函数的调用, 他们的默认参数都指向同一个
   对象

* [], (), {}: 一致的容器初始化形式
#+BEGIN_VERSE
python默认的几种可迭代类型都支持列表解析初始化形式, 如果初始化逻辑不是特别复杂且
占用空间不大推荐使用, 更清晰且效率更高
#+END_VERSE
1. 列表[i**j for i in range(10) for j in range(10) if i > 5 and j > 5]
2. 字典{i: 0 for i in range(10)}
3. 集合{i for i in range(10)}
4. 元组(i for i in range(10))
5. 函数如果支持可变参数列表, 也可用列表解析func(i for i in range(10))

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 使用Cython编写扩展模块
#+BEGIN_VERSE
使用Cython编写代码处理性能瓶颈, 这个模块根据类python代码生成c代码
#+END_VERSE
1. 使用pip install -U cython
2. 代码的编写除了类型声明以外基本和Python一致
3. 使用pyximport导入改名为.pyx结尾的原py文件, 可以无需显式编译
4. cython支持对c函数的调用
