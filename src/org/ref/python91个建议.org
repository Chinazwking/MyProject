#+STARTUP: INDENT NUM

* 理解pythonic概念
#+BEGIN_VERSE
所谓的pythonic, 即是看起来充分利用python本身的特性而编写的代码.
比如交换使用a, b = b, a, 遍历使用for i in arr, 打开文件使用with, 这些语法都是别的
语言所不具有的, 编程时要积极使用这些语法.
#+END_VERSE
1. 字符串格式化使用format
2. 包, 模块使用小字母命名且最好短小精悍, 包仅作为命名空间, __init__.py为空

* 编写pythonic代码
#+BEGIN_VERSE
想要编写pythonic的代码, 归根结底还是要全面掌握python特性, 不断学习官方推荐的新的
语法, 阅读设计良好的代码库来加深对python特性的掌握, 才能写出pythonic的代码.
#+END_VERSE
1. 变量命名
   * 避免无意义的单字母
   * 命名最好有意义, 不要产生混淆
   * 不要惧怕长命名
2. 熟练使用工具来检查代码, 比如pylint, pep8等等

* 理解python和c语言的不同之处
#+BEGIN_VERSE
虽然python是用c编写的, 但是很多语法规则上完全不同, 不要用c的思维套用到python上
#+END_VERSE
1. python使用空白缩进
2. python单引号和双引号语义上基本一致
3. python的三元操作符为xx if xx else xx
4. python没有switch, 可以用if else或者字典分发代替

* 在代码中适当添加注释
#+BEGIN_VERSE
合适的代码注释是非常有必要的, 无论是个人回顾还是提供给别人调用, 有效的注释能够节
省大量时间.
#+END_VERSE
1. 注释和代码保持一定距离更加清晰
2. 接口提供详细注释
3. 对复杂代码的思路注释而不是对实现注释
4. 错误的注释还不如没有注释, 所以更新代码时即时更新注释

* 通过适当添加空行使得代码更加优雅
#+BEGIN_VERSE
使用适当的空行分隔不同逻辑可以让代码更加有条理, 更加容易阅读
#+END_VERSE
1. 全局定义之间空两行, 类内方法空一行, 一块代码内的不同逻辑空一行
2. 一行不要超过80(这个应该是针对老式电脑编辑器的约定, 目前现代ide是否要保留感觉有
   待商榷)
3. 不要为了保持对齐而强行加入大量空白
4. 具有紧密关系的代码间不要加空格, 比如a[3], 稀疏关系的加上空格, 比如a == b
5. 空格可以用来强调关系, 比如-5 - 2, 强调是减法而不是负号

* 编写函数的四个原则
#+BEGIN_VERSE
短小精悍, 设计合理, 向下兼容, 职责明确
#+END_VERSE
1. 函数尽量短小, 循环嵌套不超过3层
2. 函数接口合理易用, 参数不宜过多
3. 设计时考虑向下兼容
4. 一个函数只做一件事, 保持同一级函数的抽象层次一致性

* 将常量集中到一个文件
#+BEGIN_VERSE
将常量定义到一个文件之中, 便于查看和维护
#+END_VERSE
两种实现方式:
   * 直接大写MAX_VALUE, 约定用法
   * 定义一个模块:
     #+BEGIN_SRC python
       class _Const:
           class ConstError(TypeError): pass
           class ConstCaseError(ConstError): pass
           def __setattr__(self, name, value):
               if self.__dict__.has_key(name):
                   raise self.ConstError, "Can't change const.%s".format(name)
               if not name.isupper():
                   raise self.ConstCaseError, "%s is not uppercase".format(name)
               self.__dict__[name] = value

       import sys
       sys.modules[__name__] = _Const()

       import const
       const.MY_CONSTANT = 1
     #+END_SRC
     使用这种方式定义可以确保变量值不变并且一定是大写

* 利用assert语句发现问题
#+BEGIN_VERSE
断言是用来捕获约束而不是捕获错误的
具体来说, 断言是用来处理程序继续执行逻辑上前提条件, 而不是具体捕获异常
#+END_VERSE
1. 不要滥用, 影响性能
2. python自身能处理就不要用断言
3. 不要用来检查用户输入
4. 可以用来检测函数返回值是否合理

* 数据交换值不推荐使用中间变量
#+BEGIN_VERSE
pythonic的交换方式是a, b = b, a
比传统的中间变量交换法更优雅且更高效
#+END_VERSE

* 充分利用lazy evaluation的特性
#+BEGIN_VERSE
利用延时计算可以节省空间, 提升性能
#+END_VERSE
1. 利用and, or的求值短路特性节省时间
2. 利用生成器节省空间

* 理解枚举替代实现的缺陷
#+BEGIN_VERSE
python3.4之前模拟的枚举存在很多缺陷, 3.4支持Enum
#+END_VERSE
1. 替代枚举可以重复赋值
2. 可以进行无意义的操作

* 不推荐使用type进行类型检查
#+BEGIN_VERSE
python的理念就是通过自动类型检查并根据需要隐式转换, 如果不行则抛出异常, 所以一般
不会主动进行类型检查
#+END_VERSE
1. type无法识别继承自内建类的类型
2. type无法识别古典类之间的区别
3. 一定要检查使用isinstance

* 尽量转换为浮点型后再做除法
#+BEGIN_VERSE
python2.7 两个整形之间默认的除法是整形除法, 会截断小数, 所以两个整数相除截断这个
效果是你想要的, 否则手动转为浮点型
#+END_VERSE
1. 可以再python2.7中使用from __future__ import division来使得默认使用浮点除法
2. 浮点数不要使用==比较, 使用a-b<=decision来指定精度进行比较

* 警惕eval()的安全漏洞
#+BEGIN_VERSE
"eval is evil"
#+END_VERSE
1. 用户可能通过eval执行破坏性代码, 所以eval不能出现在用户可能会调用的位置上
2. eval导致代码调试困难
3. 一定要暴露给用户可以使用ast.literal_eval

* 使用enumerate()获取序列迭代的索引和值
#+BEGIN_VERSE
enumerate可以优雅的处理同时获取索引和迭代值的问题, 更棒的一点是他是惰性的.
#+END_VERSE
1. 对字典使用获取的是索引和key二元组, 这个要注意

* 分清==和is的使用场景
#+BEGIN_VERSE
is判断是不是一个对象, 而==判断是不是一个值
#+END_VERSE
1. 是否为同一个对象可以理解为是不是在内存中指向同一个区域
2. == 实际上调用的是__eq__魔术方法

* 考虑兼容性, 尽可能使用Unicode
#+BEGIN_VERSE
通过统一使用unicode, 可以解决让人头疼的乱码问题
#+END_VERSE
1. 使用from __future__ import unicode_literals 可以让所有的字面量变为unicode

* 构建合理的包层次来管理module
#+BEGIN_VERSE
python中的包是用来管理组织代码结构的工具, 通过一层层目录结构, 可以使得避免不同路
径下的两个同名模块发生冲突, 并且可以根据模块的功能将其放到不同的包中, 使得代码结
构更加清晰.
#+END_VERSE
1. 通过合理的使用包, 可以让代码:
   * 便于维护和使用
   * 最大程度避免命名冲突

* 有节制的使用from ... import语法
#+BEGIN_VERSE
from import 语法虽然在有些时候减少代码量, 但是很容易导致命名冲突, 循环导入问题,
而且也不方便在运行时打猴子补丁
#+END_VERSE
1. from xx import *, 最好别用
2. from xx import ABC, 导入属性少用, 导入模块可以用
3. import xxx, 除了导致代码变长, 用起来麻烦, 其他都是优点

* 优先使用绝对导入
#+BEGIN_VERSE
绝对不要使用隐式相对导入, 有节制的使用相对导入, 最好使用绝对导入.
#+END_VERSE
1. from __future__ import absolute_import可以禁止隐式相对导入
2. 相对导入在作为顶级模块执行时会丢失自己的层次信息, 导致相对导入失效

* i+=1 不等于 ++i
#+BEGIN_VERSE
python不支持自增, ++i在python等效于+(+i), 所以这句话约等于无事发生
#+END_VERSE

* 使用with自动关闭资源
#+BEGIN_VERSE
with语句是更加优雅简单的资源管理方法, 通过with管理资源可以替代老式的
try/catch/finally式写法
本质上支持with语法的对象实现了__enter__和__exit__两个接口用来控制
资源状态
#+END_VERSE
1. 推荐使用contextlib中的contextmanager装饰器来实现自己的上下文管理器
   形式大概类似于:
   #+BEGIN_SRC python
     @contextmanager
     def mycontext():
         print('__enter__')
         # 为了确保yield的对象抛出异常能够正确__exit__, 最好还是使用try, finally
         try:
             yield 0  # yield之前为__enter__, 之后为__exit__, 返回的值会赋值给as的对象
         finally:
             print('__exit__')
   #+END_SRC
   
* 使用else字句简化循环
#+BEGIN_VERSE
else在循环中, 非break时调用, else在异常中, 没有发生异常时调用. 合理的使用else
可以减少状态变量的使用
#+END_VERSE

* 遵循异常处理的几点基本原则
#+BEGIN_VERSE
精准, 高粒度的使用异常, 注意异常捕获顺序, 正确处理异常重抛出
#+END_VERSE
1. 不要except所有异常
2. try包含的语句越少越好
3. except的异常越具体越好
4. 越在继承链底部的异常, 越应该将他放到多个except语句的前面, 以便精准捕获
5. 异常抛出的信息最好对开发, 用户更加友好

* 避免finally中可能发生的陷阱
#+BEGIN_VERSE
finally不是银弹, 并不能解决一切由异常导致的问题
#+END_VERSE
1. 如果finally里又出现了新的异常或者直接返回, 旧的异常会丢失
2. finally如果存在返回, 会截断正常的返回, 所以一般不在finally返回

* 深入理解None, 正确判断对象是否为空
#+BEGIN_VERSE
None不是空, 当一个值和None比较时, 当且仅当值也为None时他们才相等, 其他情况一律不
等
#+END_VERSE
1. python会根据对象的__nonzero__和__len__判断对象是否为空, 如果没实现这两个接口则
   默认为不空

* 连接字符串优先使用join而不是+
#+BEGIN_VERSE
在处理大规模字符串连接时, join的效率远远高于+, 所以使用join连接字符
#+END_VERSE
1. join一次性计算需要的内存, 然后将内容复制到新的字符串中
2. 每+一次都在内存中复制字符串一遍, 所以大数量时效率低

* 格式化字符串尽量使用format而不是%
#+BEGIN_VERSE
不要使用%格式化, 一律使用format
#+END_VERSE
1. 功能更强大, 更灵活, 更方便
2. %最终会被format替代

* 区别对待可变对象和不可变对象
#+BEGIN_VERSE
不可变对象的值无法改变, 而可变对象的值可以改变. 有些时候你以为不可变对象的值变了,
实际上并不是值变了, 而是给你的标识符分配了新的对象
#+END_VERSE
1. 函数默认参数绝对不要使用可变参数, 所有对函数的调用, 他们的默认参数都指向同一个
   对象

* [], (), {}: 一致的容器初始化形式
#+BEGIN_VERSE
python默认的几种可迭代类型都支持列表解析初始化形式, 如果初始化逻辑不是特别复杂且
占用空间不大推荐使用, 更清晰且效率更高
#+END_VERSE
1. 列表[i**j for i in range(10) for j in range(10) if i > 5 and j > 5]
2. 字典{i: 0 for i in range(10)}
3. 集合{i for i in range(10)}
4. 元组(i for i in range(10))
5. 函数如果支持可变参数列表, 也可用列表解析func(i for i in range(10))

* 记住函数传参既不是传值也不是传引用
#+BEGIN_VERSE
python的传参是传对象的引用, 不是传值也不是传引用
#+END_VERSE
1. 对于任何形参, 在内部给形参赋值都相当于给引用指向了一个新的内存, 不会修改实参
2. 对于可变类型形参, 如果只是修改形参的值, 那么由于和实参引用的是同一个内存, 也会
   影响到实参的值

* 警惕默认参数的潜在问题
#+BEGIN_VERSE
默认参数不要使用可变对象, 除非你清楚的知道这样做的后果是你想要的
#+END_VERSE
1. 如果默认参数是可变对象, 函数内每次对可变参数的修改都会影响下一次调用, 因为可变
   参数只会初始化一次, 后面的所有调用用的都是同一个可变参数
2. 如果你就是想要参数动态变化的效果, 比如说默认参数是当前时间, 那么可以让参数为:
   #+BEGIN_SRC python
     import time
     def print_time(time=time.time):
         print(time())
   #+END_SRC

* 慎用变长参数
#+BEGIN_VERSE
变长参数会导致接口定义非常不明确, 想要调用接口要求必须对变长参数含义有精确的理解,
脱离了接口简单易用的本意, 所以谨慎使用
#+END_VERSE
1. 使用变长参数时, 考虑此函数是否功能过多, 是否需要重构
2. 如果仅仅只是想要传字典或者列表, 不要用可变参数
3. 在参数数目不定, 实现函数多态和装饰器, 或子类调用父类方法时可以使用可变参数

* 深入理解str()和repr()的区别
#+BEGIN_VERSE
str面向用户, repr面向解释器
#+END_VERSE
1. 当str没实现时会调用repr, 所以一般要实现repr
2. 一般情况下来说有如下等式, obj == eval(repr(obj))
3. print调用的是str, 交互环境里直接输入变量调用的是repr

* 分清staticmethod和classmethod的适用场景
#+BEGIN_VERSE
静态方法是放置于类内的普通函数, 功能和放到类外的函数是一致的, 出于代码紧凑和组织
原因才放到类内部, 而类方法一般用于和类本身属性有关的情况, 比如说修改类属性, 类工
厂函数等等
#+END_VERSE
1. 静态方法在语义上和类没有任何关系
2. 类方法可以动态根据调用类方法的类来修改类本身属性

* 掌握字符串的基本用法
#+BEGIN_VERSE
字符串有很多很方便的接口, 需要仔细阅读阅读一下文档, 对接口大概心里有数
#+END_VERSE
1. 判断对象是否为字符串使用isinstance(obj, basestring)
2. split('')和split()的结果是不一样的, 后者会认为所有的连续的空字符为一个间隔
3. 字符串自带很多控制格式的接口, 可以更加准确的控制排版

* 按需选择sort()和sorted()
#+BEGIN_VERSE
如果想要节省空间且自身是list则使用sort原地排序, 否则一般使用sorted进行排序, 它支
持序列类型, 且不修改原对象
#+END_VERSE
1. 都支持key参数, reverse参数, 可以灵活的控制排序规则和结果
2. cmp参数尽量少用, 因为效率要低于key参数

* 适用copy模块深拷贝对象
#+BEGIN_VERSE
如果想要拷贝出一个完全独立的对象, 使用copy.deepcopy
#+END_VERSE
1. 浅拷贝是指仅复制最外层, 如果内层还有引用则复制出来的新对象和原对象内层指的还是
   同一个单位
2. 深拷贝是指遇到引用会递归拷贝其所指向的内容, 直到最底层, 所以可以复制出一个和原
   对象完全没关系的新对象

* 适用Counter进行计数统计
#+BEGIN_VERSE
如果有统计序列中元素数目的需求, 请使用collections.Counter
#+END_VERSE
1. 支持+, -, |, &等集合操作
2. 使用elements获得所有元素, 使用most_common获得数量最多的元素及其次数
3. 使用update, subtract来改变各个元素的数目

* 深入掌握ConfigParser
#+BEGIN_VERSE
ConfigParser可以用来读取ini文件格式的配置信息
#+END_VERSE
1. getboolean()可以将0, no, false, off都转为False, 1, yes, true, on转为True, 其
   他抛出异常
2. 当在指定的节[section]找不到配置项时, 回去[DEFAULT]节中去寻找
3. 配置项支持参数替换, 比如coon_str = %(user)s:%(pw)s, 如果查找的节内有user和pw的
   定义, 则会自动替换占位符

* 适用argparse处理命令行参数
#+BEGIN_VERSE
python提供了argparse用来优雅的处理命令行参数, 需要的时候记得使用
#+END_VERSE
- 示例:
  #+BEGIN_SRC python
    import argparse

    parser = argparse.ArgumentParser(description='argsparse example')
    # 支持参数分组
    pos = parser.add_argument_group('positional', 'positional argument example')
    # default代表默认参数, choices代表取值范围, help代表描述
    pos.add_argument('str', type=str, choices=['a', 'b'], help='word')
    # type代表期望输入的类型, list是参数名， nargs代表至少输入一个参数(可以接受多个)
    pos.add_argument('list', type=int, nargs='+',
                    help='positional arguments example')
    opt = parser.add_argument_group('optional', 'optional argument example')
    # --开始代表需要参数的参数, default为默认值
    opt.add_argument('--name', type=str, default='dog', help='name')
    # required代表必须输入, '-a'为'--age'简写
    opt.add_argument('-a', '--age', type=int, required=True, help='age')
    # 不带参数的可选参数, 一般当作开关, dest代表存储名称, action代表默认操作
    opt.add_argument('-v', dest='verbose', action='store_true', help='verbose')
    # 子命令sub
    subparser = parser.add_subparsers(help='sub-command help')
    parser_sub = subparser.add_parser('sub', help='sub help')
    parser_sub.add_argument('--test', type=bool, help='is test')
    parser_sub.add_argument('bool', type=str, help='bool')

    args = parser.parse_args()
    print(args)
  #+END_SRC
- 使用ArgumentParser实例方法exit和error来处理异常情况

* 适用pandas处理大型CSV文件
#+BEGIN_VERSE
csv文件是指(Comma Seperated Values)文件, 一般是以,分隔的文件, excel就属于此类
python提供了库csv用来处理这种文件类型
#+END_VERSE
- 实例:
  #+BEGIN_SRC python
    import csv
    """假设test.csv中内容为
    name, A, B, C, D
    a, 1, 2, 3, 4
    b, 5, 6, 7, 8
    """
    with open('test.csv', 'r+') as fp:
        result = []
        for row in csv.reader(fp):
            result.append(row)
            print(row)
        """输出为:
        ['name', 'A', 'B', 'C', 'D'],
        ['a', '1', ...]
        ['b', 'b', ...]
        """
        fp.seek(0)
        # delimiter代表写入时使用的分隔符, 默认是,
        writer = csv.writer(fp, delimiter=':')
        # DictWriter用法和此类似
        for row in result:
            writer.writerow(row)
        fp.seek(0)
        for row in csv.DictReader(fp, delimiter=':'):
            print(row)
        """输出为:
        {' B': ' 2', ' C': ' 3', ' A': ' 1', 'name': 'a', ' D': ' 4'}
        {' B': ' 6', ' C': ' 7', ' A': ' 5', 'name': 'b', ' D': ' 8'}
        以行标签作为键分隔
        """
  #+END_SRC
- 如果碰到上百M的大文件, 使用pandas来进行处理是比较好的选择

* 一般情况适用ElementTree解析XML
#+BEGIN_VERSE
处理xml文件时, 请使用ElementTree模块来处理
#+END_VERSE
1. 使用简单, 将整个xml作为树, 每一个元素的属性以字典表示
2. 内存消耗低
3. 支持XPath, 非常方便获取任意节点的值
- 示例:
  #+BEGIN_SRC python
    try:
        # 优先加载cElementTree, 性能更好
        import xml.etree.cElementTree as ET
    except ImportError:
        import xml.etree.ElementTree as ET

    """假设text.xml文件内容为:
    <test>
        <name author='wzw' age='10'>
            <purpose>test</purpose>
        </name>
    </test>
    """

    tree = ET.parse("test.xml")
    root = tree.getroot()
    print('root tag={}'.format(root.tag))  # 打印根元素的tag
    # 遍历xml文档的第二层
    for child in root:
        # 第二层节点的标签名称和属性
        print('tag={} attrib={}'.format(child.tag, child.attrib))
        for children in child:
            # 第三层节点的标签名称和属性
            print('tag={}, value={}'.format(children.tag, children.text))
    # 如果不想一层层遍历, 直接使用find等接口可以直接定位到准确层级, 比如find('name/purpose').text == 'test'

    """输出为:
    root tag=test
    tag=name attrib={'age': '10', 'author': 'wzw'}
    tag=purpose, value=test
    """
  #+END_SRC

* 理解模块pickle优劣
#+BEGIN_VERSE
pickle是python提供的一种通用的序列化/反序列化接口, 基本支持大部分python类型, 包括
类, 函数这些比较刁钻的类型
#+END_VERSE
- 优点:
  1. 接口简单易用, 使用load和dump (由于序列化出来的东西不像json一样可读, 所以带s
     两个接口不常用)
  2. 存储格式在不同平台的python之间通用
  3. 支持广泛的数据类型
  4. 模块支持扩展来处理自定义的类型
  5. 能够自动维护对象间的引用
- 缺点:
  1. 不能保证操作的原子性
  2. 存在安全性问题, 可以通过loads执行破坏性代码
  3. python特定格式, 不同语言之间无法解析
- 实例:
  #+BEGIN_SRC python
    import pickle
    def test():
        print('test')
    pickle.loads(pickle.dumps(test))()
  #+END_SRC

* 序列化的另一个不错的选择
#+BEGIN_VERSE
python自带对json的完全支持, 对序列化性能要求不是特别高的情况优先使用.
主要用4个接口, load, loads, dump, dumps, 不带s的操作文件, 带s操作字符串
#+END_VERSE
1. 简单易用, 支持多种数据类型(null, str, int, float, bool, list, dict)
2. 存储可读性更好
3. 支持跨平台操作
4. 可以扩展来支持json本身不支持的类型
5. 示例:
   #+BEGIN_SRC python
     import json
     obj = {'a': {'b': [1, 2, 3], 'c': True}, 'b': 'help', 'c': 1.5}
     sResult = json.dumps(obj)  # sResult is str
     new_obj = json.loads(sResult)
     print(new_obj == obj)
   #+END_SRC
   
* 适用traceback获取栈信息
#+BEGIN_VERSE
#+END_VERSE

* 适用logging记录日志信息
#+BEGIN_VERSE
#+END_VERSE

* 适用threading编写多线程程序
#+BEGIN_VERSE
#+END_VERSE

* 适用Queue使多线程编程更安全
#+BEGIN_VERSE
#+END_VERSE

* 利用模块使用单例模式
#+BEGIN_VERSE
#+END_VERSE

* 用mixin模式让程序更加灵活
#+BEGIN_VERSE
#+END_VERSE

* 用发布订阅模式实现松耦合
#+BEGIN_VERSE
#+END_VERSE

* 用状态模式美化代码
#+BEGIN_VERSE
#+END_VERSE

* 理解build-in objects
#+BEGIN_VERSE
#+END_VERSE

* __init__()不是构造方法
#+BEGIN_VERSE
#+END_VERSE

* 理解名字查找机制
#+BEGIN_VERSE
#+END_VERSE

* 为什么需要self参数
#+BEGIN_VERSE
#+END_VERSE

* 理解MRO与多继承
#+BEGIN_VERSE
#+END_VERSE

* 理解描述符机制
#+BEGIN_VERSE
#+END_VERSE

* 区别__getattr__()和__getattribute__()方法
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 
#+BEGIN_VERSE
#+END_VERSE

* 使用Cython编写扩展模块
#+BEGIN_VERSE
使用Cython编写代码处理性能瓶颈, 这个模块根据类python代码生成c代码
#+END_VERSE
1. 使用pip install -U cython
2. 代码的编写除了类型声明以外基本和Python一致
3. 使用pyximport导入改名为.pyx结尾的原py文件, 可以无需显式编译
4. cython支持对c函数的调用
