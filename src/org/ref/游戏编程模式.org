#+STARTUP: INDENT NUM

* 架构, 游戏和性能
  1. 游戏编程流程图:
     #+BEGIN_VERSE
     遇到问题 \rarr 学习代码 \rarr 解决方案 \rarr 解决问题
     所以尽可能解耦, 使得可以学习较少代码便能得到解决方案
     #+END_VERSE
  2. 在游戏开发期, 游戏的灵活性要大于游戏的效能
     #+BEGIN_VERSE
     游戏的灵活性越大, 开发迭代速度越快, 游戏便越有趣. 将一个好玩的游戏做的高效总
     是比将一款高效的游戏做的有趣要简单
     所以使用抽象使游戏变得灵活, 当其稳定后去除部分抽象提高性能
     #+END_VERSE
  3. 原型开发是完全正确的开发实践
     #+BEGIN_VERSE
     快速的开发一个原型来验证想法, 无需考虑原型的代码设计和维护, 只需要能运行即可
     用完一定要将其丢掉, 如果确认使用则仔细设计并重新实现
     一个比较良好的习惯是使用另一种语言来开发原型, 这样即便你想使用, 也必须用游戏
     语言来重新开发
     #+END_VERSE
  4. 保持游戏的简单性
     #+BEGIN_VERSE
     使用一段代码来处理一系列逻辑, 事物背后是普遍联系的, 找出共性来解决相似的问题
     而不是使用累加的if else
     #+END_VERSE
  5. 经典名言: 提前优化是万恶之源
  6. 如果要做一些有趣的游戏, 请乐在其中

* 命令模式
1. 什么是命令
   #+BEGIN_VERSE
   命令就是面向对象化的回调
   通过命令将输入和操作解耦
   #+END_VERSE
2. 经典场景, 撤销和重做
   #+BEGIN_SRC c++
     class Command {
      public:
       virtual ~Command() {}
       virtual void Execute() = 0;
       virtual void Undo() = 0
     };
   #+END_SRC
   存储一个命令栈:
   older.. | cmd | cmd | cmd | cmd | cmd | newer..
                    \uparrow     \uparrow     \uparrow
                  undo   cur   redo
   每当undo则将三个指针向前移动, redo则向后移动, 如果有新的命令则将cur后面的命令
   全部丢弃
3. 如果存在很多命令, 可以使用[[*][子类沙盒模式]]来在高层提供很多通用函数, 子类命令组合这些函数
4. 如果对象模型存在分层情况, 可以使用[[*责任链][责任链模式]]来将命令转发给附属对象
5. 如果命令是无状态的代码块, 可以使用[[*][享元模式]]来降低内存使用
   
