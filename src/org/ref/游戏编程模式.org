#+STARTUP: INDENT NUM

* 架构, 游戏和性能
  1. 游戏编程流程图:
     #+BEGIN_VERSE
     遇到问题 \rarr 学习代码 \rarr 解决方案 \rarr 解决问题
     所以尽可能解耦, 使得可以学习较少代码便能得到解决方案
     #+END_VERSE
  2. 在游戏开发期, 游戏的灵活性要大于游戏的效能
     #+BEGIN_VERSE
     游戏的灵活性越大, 开发迭代速度越快, 游戏便越有趣. 将一个好玩的游戏做的高效总
     是比将一款高效的游戏做的有趣要简单
     所以使用抽象使游戏变得灵活, 当其稳定后去除部分抽象提高性能
     #+END_VERSE
  3. 原型开发是完全正确的开发实践
     #+BEGIN_VERSE
     快速的开发一个原型来验证想法, 无需考虑原型的代码设计和维护, 只需要能运行即可
     用完一定要将其丢掉, 如果确认使用则仔细设计并重新实现
     一个比较良好的习惯是使用另一种语言来开发原型, 这样即便你想使用, 也必须用游戏
     语言来重新开发
     #+END_VERSE
  4. 保持游戏的简单性
     #+BEGIN_VERSE
     使用一段代码来处理一系列逻辑, 事物背后是普遍联系的, 找出共性来解决相似的问题
     而不是使用累加的if else
     #+END_VERSE
  5. 经典名言: 提前优化是万恶之源
  6. 如果要做一些有趣的游戏, 请乐在其中

* 命令模式
1. 什么是命令
   #+BEGIN_VERSE
   命令就是面向对象化的回调
   通过命令将输入和操作解耦
   #+END_VERSE
2. 经典场景, 撤销和重做
   #+BEGIN_SRC c++
     class Command {
      public:
       virtual ~Command() {}
       virtual void Execute() = 0;
       virtual void Undo() = 0
     };

     class EditCommand: public Command {
      public:
       EditCommand() {}
       void Execute() {
         // do something
       }
       void Undo() {
         // undo it
       }
     };
   #+END_SRC
   存储一个命令栈:
   older.. | cmd | cmd | cmd | cmd | cmd | newer..
                    \uparrow     \uparrow     \uparrow
                  undo   cur   redo
   每当undo则将三个指针向前移动, redo则向后移动, 如果有新的命令则将cur后面的命令
   全部丢弃
3. 如果存在很多命令, 可以使用[[*子类沙盒][子类沙盒模式]]来在高层提供很多通用函数, 子类命令组合这些函数
4. 如果对象模型存在分层情况, 可以使用[[*责任链][责任链模式]]来将命令转发给附属对象
5. 如果命令是无状态的代码块, 可以使用[[*享元模式][享元模式]]来降低内存使用
   
* 享元模式
1. 什么是享元
   #+BEGIN_VERSE
   当大量对象内部数据分为两种类型:
   - 内部数据(上下文无关): 这部分数据在所有的对象中都是一致的, 和所处的对象没有关系
   - 外部数据(上下文相关): 这部分数据代表每个对象自己的特征
   通过将内部数据存储到一个对象中, 大量对象持有内部数据的引用即可有效的减少内存的使用
   我们把这些内部对象称为享元(共享的单元)
   #+END_VERSE
2. 经典场景, 瓦片世界
   #+BEGIN_SRC c++
     class Terrain {  // 地形类, 拥有自己的移动开销和纹理
      public:
       Terrain(int movecost, Texture texture);
       int getMoveCost() const;
       const Texture& getTexture() const;

      private:
       int _movecost;
       Texture _texture;
     };

     class World {
      public:
       World() {
         _landtile = Terrain(10, landTexture);
         // ...其他地形初始化
         for (int i = 0; i < 1000; ++i) {
           for (int j = 0; j < 1000; ++j) {
             _world[i][j] = choice(); // 在4中地形中随机选择一个
           }
         }
       }

      private:
       // 4种独特地形的引用
       Terrain* _landtile;
       Terrain* _watertile;
       Terrain* _foresttile;
       Terrain* _sandtile;

       // 世界所有地块
       Terrain* _world[1000][1000];
     }
   #+END_SRC
   假设一个游戏的世界由若干不同地形构成, 每种地形都有自己的移动开销和纹理, 因为地形的
   种类是有限的, 但是整个世界的地块确可能存在千千万万, 这里便可以应用享元模式.
   不必未每个地块单独生成自己的地形, 而是让若干地块共享一个地形实例
3. 如果不能预测共有多少享元, 那么最好按需创建, 可以使用[[*][工厂模式]]管理创建操作
4. 为了更方便的管理享元, 可以使用[[*对象池][对象池模式]]来管理
5. [[*状态模式][状态模式]]的状态也可以使用享元来表现

* 观察者模式
1. 什么是观察者
   #+BEGIN_VERSE
   在对象之间定义一种一对多的关系, 以便当某个对象改变时, 与他存在依赖关系的所有对象
   都能收到通知并自动更新
   #+END_VERSE
2. 经典场景, 成就系统
   #+BEGIN_SRC c++
     class Observer {
      public:
       virtual ~Observer() {}
       virtual void onNotify(const Entity& entity, Event event) = 0;
     };

     class Achievements: public Observer {
      public:
       virtual void onNotify(const Entity& entity, Event event) {
         switch (event) {
           case EVENT_FELL:
             if (entity.isHero()) {
               unlock(ACHIEVEMENT_FELL);  // 解锁跌落成就
             }
             break;
         }
       }

      private:
       void unlock(Achievement achievement) {
         // 解锁成就
       }
     };

     class Subject {
      public:
       void addObserver(Observer* observer) {
         // 加到观察者列表中
       }

       // 移除观察者等其他操作

      protected:
       void notify(const Entity& entity, Event event) {  // 通知所有观察者
         for(auto& observer : _observers) {
           observer->onNotify(entity, event)
         }
       }

      private:
       Observer* _observers[MAX_OBSERVERS];
     };

     class Physics: public Subject {  // 物理系统
      public:
       void updateEntity(Entity& entity) {
         notify(entity, EVENT_FELL);  // 发出掉落信号
       }
       // 其他接口
     };
   #+End_src
   当玩家坠地时解锁成就玩家坠落, 但是很明显玩家坠地属于物理系统, 而在物理系统处理成就
   会非常奇怪, 而且玩家坠地也有可能有声音, 动画等等特效, 很明显不能将这些效果和物理系统
   耦合到一起, 物理系统只应该处理物理相关的事.
   通过将成就系统注册为物理系统的观察者, 使得物理无需和成就系统耦合. 物理系统只需要
   处理物理相关的事件并广播出去, 并不关心其他系统如何处理, 最终实现了成就系统和物理
   系统同步且两者可以独立变化
3. 当一个观察者或被观察者过期时, 注意两者的销毁
4. 观察者适用于处理不相关模块的通信问题, 不适用于在单个紧凑的内部模块内通信使用
5. 目前更流行使用更灵活的观察者方法, 比如注册一个观察函数, 而不是继承一个类

* 原型模式
1. 什么是原型
   #+BEGIN_VERSE
   使用特定原型实例来创建特定种类的对象, 并且通过拷贝原型来创建新的对象
   #+END_VERSE
2. 经典场景, 怪物系统
   #+CAPTION: 怪物实现
   #+BEGIN_SRC c++
     class Monster {
      public:
       virtual ~Monster() {}
       virtual Monster* clone() = 0;
     };

     class Slime : public Monster {
      public:
       Slime(int health, int speed)
           :_health(health) {}

       virtual Monster* clone() {
         return new Slime(_health)
       }

      private:
       int _health;
     };
   #+End_src
   无需定义工厂函数, 通过clone方法, 每个实例可以复制自身, 并且同时复制自身的状态
   来创建若干个怪物对象
   #+CAPTION: 怪物数据建模
   #+BEGIN_SRC json
     [
         {
             "name": "slime",
             "maxHealth": 100,
             "resists": ["cold", "posion"],
             "weakness": ["fire", "light"]
         },
         {
             "name": "slime queen",
             "prototype": "slime",
             "spells": ["fire ball", "ice nova"]
         },
         {
             "name": "slime king",
             "prototype": "slime",
             "attacks": ["cyclone", "charge"]
         }
     ]
   #+END_SRC
   通过为每个怪物json设置原型字段, 可以有效实现相似怪物的属性共享, 新建怪物类型也
   非常简单, 使用prototype字段设置一个原型
3. 实现原型的clone时, 一定要注意对象的拷贝问题(深拷贝, 浅拷贝)
4. [[*类型对象][类型对象模式]]和和原型模式有一定的共同点

* 单例模式
1. 什么是单例
   #+BEGIN_VERSE
   确保一个类只有一个实例, 并为其提供一个全局访问入口
   #+END_VERSE
2. 经典场景, 文件系统
   #+BEGIN_SRC c++
     class FileSystem {
      public:
       static FileSystem& instance() {
         #if PLATFORM = PLAYSTATION4
           static FileSystem* instance = new PS4FileSystem();
         #elif PLATFORM = SWITCH
           static FileSystem* instance = new SwitchFileSystem();
         #endif
         return *instance
       }
       virtual ~FileSystem() {}
       virtual char* read(char* path) = 0;
       virtual void write(char* path, char* text) = 0;

      private:
       FileSystem() {}
     };

     class PS4FileSystem: public FileSystem {
      public:
       virtual char* read(char* path) {}
       virtual void write(char* path, char* text) {}
     };

     class SwitchFileSystem: public FileSystem {
      public:
       virtual char* read(char* path) {}
       virtual void write(char* path, char* text) {}
     };
   #+End_src
   C++11保证局部静态变量只会初始化一次且线程安全, 通过instace接口, 全局
   都访问同一个FileSystem实例, 通过继承和简单的编译跳转实现了跨平台的文件
   系统功能封装
3. 不要滥用单例模式
   1. 他是一个全局变量
      1. 由于任何位置都能修改单例, 导致追踪问题时需要额外考虑全局单例状态, 导致
         代码晦涩难懂
      2. 全局变量促进了耦合, 由于单例的易访问性, 使用者很可能在任何位置都不自主的
         使用单例, 导致不相干的模块耦合到一起
      3. 对并发不友好
   2. 延迟初始化不一定是件好事, 在错误的时间初始化可能导致游戏明显卡顿, 所以
      很多时候会选择静态类初始化, 此时单例没有意义
4. 单例的替代品
   1. 首先考虑你是否真的需要单例
   2. 是否可以通过传参的方式替代单例
   3. 是否可以在基类中获取
   4. 将分散的单例作为成员变量封装到一个全局对象中
   5. 使用[[*服务定位器][服务定位器]]来访问
   6. [[*子类沙盒][子类沙盒]]可以为子类提供一些共享的状态访问, 而不必全局可见
* 状态模式
* 双缓冲
* 游戏循环
* 更新方法
* 字节码
* 子类沙盒
* 类型对象
* 组件模式
* 事件队列
* 服务定位器
* 数据局部性
* 脏标记模式
* 对象池
* 空间分区
