#+STARTUP: INDENT NUM

* 架构, 游戏和性能
  1. 游戏编程流程图:
     #+BEGIN_VERSE
     遇到问题 \rarr 学习代码 \rarr 解决方案 \rarr 解决问题
     所以尽可能解耦, 使得可以学习较少代码便能得到解决方案
     #+END_VERSE
  2. 在游戏开发期, 游戏的灵活性要大于游戏的效能
     #+BEGIN_VERSE
     游戏的灵活性越大, 开发迭代速度越快, 游戏便越有趣. 将一个好玩的游戏做的高效总
     是比将一款高效的游戏做的有趣要简单
     所以使用抽象使游戏变得灵活, 当其稳定后去除部分抽象提高性能
     #+END_VERSE
  3. 原型开发是完全正确的开发实践
     #+BEGIN_VERSE
     快速的开发一个原型来验证想法, 无需考虑原型的代码设计和维护, 只需要能运行即可
     用完一定要将其丢掉, 如果确认使用则仔细设计并重新实现
     一个比较良好的习惯是使用另一种语言来开发原型, 这样即便你想使用, 也必须用游戏
     语言来重新开发
     #+END_VERSE
  4. 保持游戏的简单性
     #+BEGIN_VERSE
     使用一段代码来处理一系列逻辑, 事物背后是普遍联系的, 找出共性来解决相似的问题
     而不是使用累加的if else
     #+END_VERSE
  5. 经典名言: 提前优化是万恶之源
  6. 如果要做一些有趣的游戏, 请乐在其中

* 命令模式
1. 什么是命令
   #+BEGIN_VERSE
   命令就是面向对象化的回调
   通过命令将输入和操作解耦
   #+END_VERSE
2. 经典场景, 撤销和重做
   #+BEGIN_SRC c++
     class Command {
      public:
       virtual ~Command() {}
       virtual void Execute() = 0;
       virtual void Undo() = 0
     };
   #+END_SRC
   存储一个命令栈:
   older.. | cmd | cmd | cmd | cmd | cmd | newer..
                    \uparrow     \uparrow     \uparrow
                  undo   cur   redo
   每当undo则将三个指针向前移动, redo则向后移动, 如果有新的命令则将cur后面的命令
   全部丢弃
3. 如果存在很多命令, 可以使用[[*][子类沙盒模式]]来在高层提供很多通用函数, 子类命令组合这些函数
4. 如果对象模型存在分层情况, 可以使用[[*责任链][责任链模式]]来将命令转发给附属对象
5. 如果命令是无状态的代码块, 可以使用[[*享元模式][享元模式]]来降低内存使用
   
* 享元模式
1. 什么是享元
   #+BEGIN_VERSE
   当大量对象内部数据分为两种类型:
   - 内部数据(上下文无关): 这部分数据在所有的对象中都是一致的, 和所处的对象没有关系
   - 外部数据(上下文相关): 这部分数据代表每个对象自己的特征
   通过将内部数据存储到一个对象中, 大量对象持有内部数据的引用即可有效的减少内存的使用
   我们把这些内部对象称为享元(共享的单元)
   #+END_VERSE
2. 经典场景, 瓦片世界
   #+BEGIN_SRC c++
     class Terrain {  // 地形类, 拥有自己的移动开销和纹理
      public:
       Terrain(int movecost, Texture texture);
       int getMoveCost() const;
       const Texture& getTexture() const;

      private:
       int _movecost;
       Texture _texture;
     };

     class World {
      public:
       World() {
         _landtile = Terrain(10, landTexture);
         // ...其他地形初始化
         for (int i = 0; i < 1000; ++i) {
           for (int j = 0; j < 1000; ++j) {
             _world[i][j] = choice(); // 在4中地形中随机选择一个
           }
         }
       }

      private:
       // 4种独特地形的引用
       Terrain* _landtile;
       Terrain* _watertile;
       Terrain* _foresttile;
       Terrain* _sandtile;

       // 世界所有地块
       Terrain* _world[1000][1000];
     }
   #+END_SRC
   假设一个游戏的世界由若干不同地形构成, 每种地形都有自己的移动开销和纹理, 因为地形的
   种类是有限的, 但是整个世界的地块确可能存在千千万万, 这里便可以应用享元模式.
   不必未每个地块单独生成自己的地形, 而是让若干地块共享一个地形实例
3. 如果不能预测共有多少享元, 那么最好按需创建, 可以使用[[*][工厂模式]]管理创建操作
4. 为了更方便的管理享元, 可以使用[[*对象池模式][对象池模式]]来管理
5. [[*状态机模式][状态机模式]]的状态也可以使用享元来表现

* 观察者模式
1. 什么是观察者
   #+BEGIN_VERSE
   在对象之间定义一种一对多的关系, 以便当某个对象改变时, 与他存在依赖关系的所有对象
   都能收到通知并自动更新
   #+END_VERSE
2. 经典场景, 成就系统
   #+BEGIN_SRC c++
     class Observer {
      public:
       virtual ~Observer() {}
       virtual void onNotify(const Entity& entity, Event event) = 0;
     };

     class Achievements: public Observer {
      public:
       virtual void onNotify(const Entity& entity, Event event) {
         switch (event) {
           case EVENT_FELL:
             if (entity.isHero()) {
               unlock(ACHIEVEMENT_FELL);  // 解锁跌落成就
             }
             break;
         }
       }

      private:
       void unlock(Achievement achievement) {
         // 解锁成就
       }
     };

     class Subject {
      public:
       void addObserver(Observer* observer) {
         // 加到观察者列表中
       }

       // 移除观察者等其他操作

      protected:
       void notify(const Entity& entity, Event event) {  // 通知所有观察者
         for(auto& observer : _observers) {
           observer->onNotify(entity, event)
         }
       }

      private:
       Observer* _observers[MAX_OBSERVERS];
     };

     class Physics: public Subject {  // 物理系统
      public:
       void updateEntity(Entity& entity) {
         notify(entity, EVENT_FELL);  // 发出掉落信号
       }
       // 其他接口
     };
   #+End_src
   当玩家坠地时解锁成就玩家坠落, 但是很明显玩家坠地属于物理系统, 而在物理系统处理成就
   会非常奇怪, 而且玩家坠地也有可能有声音, 动画等等特效, 很明显不能将这些效果和物理系统
   耦合到一起, 物理系统只应该处理物理相关的事.
   通过将成就系统注册为物理系统的观察者, 使得物理无需和成就系统耦合. 物理系统只需要
   处理物理相关的事件并广播出去, 并不关心其他系统如何处理, 最终实现了成就系统和物理
   系统同步且两者可以独立变化
3. 当一个观察者或被观察者过期时, 注意两者的销毁
4. 观察者适用于处理不相关模块的通信问题, 不适用于在单个紧凑的内部模块内通信使用
5. 目前更流行使用更灵活的观察者方法, 比如注册一个观察函数, 而不是继承一个类

* 原型模式
